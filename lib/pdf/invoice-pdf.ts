import prisma from "@/lib/prisma"
import { formatCurrency, formatDate } from "@/lib/utils"
import type { Currency } from "@/app/generated/prisma/client"

export async function generateInvoicePdf(invoiceId: string): Promise<Buffer> {
  const invoice = await prisma.invoice.findUnique({
    where: { id: invoiceId },
    include: {
      company: { select: { name: true, email: true, slug: true } },
    },
  })

  if (!invoice) throw new Error("Invoice not found")

  // Fetch usage record for the period
  const usageRecord = await prisma.usageRecord.findUnique({
    where: {
      companyId_periodStart: {
        companyId: invoice.companyId,
        periodStart: invoice.periodStart,
      },
    },
  })

  // Dynamic imports to avoid Turbopack static analysis issues with fflate Worker
  const { default: jsPDF } = await import("jspdf")
  const { default: autoTable } = await import("jspdf-autotable")

  const doc = new jsPDF()

  // Header
  doc.setFontSize(24)
  doc.setTextColor(99, 102, 241) // indigo
  doc.text("NeonMeter", 14, 25)

  doc.setFontSize(10)
  doc.setTextColor(100, 116, 139) // slate-500
  doc.text("Usage-Based Billing for Neon PostgreSQL", 14, 32)

  // Invoice info
  doc.setFontSize(18)
  doc.setTextColor(15, 23, 42) // slate-900
  doc.text(`Invoice ${invoice.invoiceNumber}`, 14, 48)

  doc.setFontSize(10)
  doc.setTextColor(100, 116, 139)

  const infoY = 58
  doc.text(`Bill To: ${invoice.company.name}`, 14, infoY)
  if (invoice.company.email) {
    doc.text(`Email: ${invoice.company.email}`, 14, infoY + 6)
  }
  doc.text(`Period: ${formatDate(invoice.periodStart)} - ${formatDate(invoice.periodEnd)}`, 14, infoY + 12)
  doc.text(`Due Date: ${formatDate(invoice.dueDate)}`, 14, infoY + 18)
  doc.text(`Status: ${invoice.status}`, 14, infoY + 24)

  // Amount
  doc.setFontSize(14)
  doc.setTextColor(15, 23, 42)
  doc.text(`Amount: ${formatCurrency(invoice.amountCents, invoice.currency as Currency)}`, 140, infoY)

  // Usage breakdown table
  if (usageRecord) {
    const computeHours = +(usageRecord.computeUnitSeconds / 3600).toFixed(2)
    const storageGB = +((usageRecord.rootBranchBytesMonth + usageRecord.childBranchBytesMonth) / (1024 ** 3)).toFixed(3)
    const writtenGB = +(usageRecord.writtenDataBytes / (1024 ** 3)).toFixed(3)
    const transferGB = +((usageRecord.publicNetworkTransferBytes + usageRecord.privateNetworkTransferBytes) / (1024 ** 3)).toFixed(3)

    autoTable(doc, {
      startY: infoY + 35,
      head: [["Metric", "Value", "Unit"]],
      body: [
        ["Compute Time", String(computeHours), "hours"],
        ["Storage (root + child)", String(storageGB), "GB"],
        ["Data Written", String(writtenGB), "GB"],
        ["Network Transfer", String(transferGB), "GB"],
        ["Neon Estimated Cost", formatCurrency(usageRecord.estimatedCostNeonCents, invoice.currency as Currency), ""],
        ["Billed Amount (with markup)", formatCurrency(usageRecord.billedAmountCents, invoice.currency as Currency), ""],
      ],
      styles: { fontSize: 9 },
      headStyles: { fillColor: [99, 102, 241] },
    })
  }

  // Footer
  const pageHeight = doc.internal.pageSize.height
  doc.setFontSize(8)
  doc.setTextColor(148, 163, 184)
  doc.text("Generated by NeonMeter - Automated Neon PostgreSQL Billing", 14, pageHeight - 10)

  // Return as Buffer
  const arrayBuffer = doc.output("arraybuffer")
  return Buffer.from(arrayBuffer)
}
